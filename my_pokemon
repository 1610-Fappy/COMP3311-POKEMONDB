#! /usr/bin/env python3


"""
COMP3311
23T1
Assignment 2
Pokemon Database

Written by: <YOUR NAME HERE> <YOUR STUDENT ID HERE>
Written on: <DATE HERE>

My Pokemon

Create your very own Pokemon
"""


import sys
import psycopg2
import helpers
from random import Random


### Constants
USAGE = f"Usage: {sys.argv[0]} <Seed>"


### Globals
db = None
Seed = None
rng = None


### Command-line args
if len(sys.argv) != 2:
    print(USAGE, file=sys.stderr)
Seed = int(sys.argv[1]) # read the seed from the command line
rng  = Random(Seed)     # set the seed for the python random number generator

# `rng` is a python Random number generator
# `rng.random()` returns a random float between 0 and 1
# `rng.randint(a, b)` returns a random integer between a and b (inclusive)

# `SELECT setseed(seed);` sets the postgres random seed to `seed`
# `SELECT * FROM Table ORDER BY random() LIMIT 5;` gives 5 random rows from the table `Table`
# `SELECT setseed(seed);` should be used once, before any calls to random(), with the a random number generated by `rng.random()`

def menu(items: list[str]) -> int:
    """
    Given a list of strings,
    print a numbered menu
    and return the user's selection.
    """
    padding = len(str(len(items)))
    print(f"Select an option from the menu below by entering its number:")
    for i, item in enumerate(items):
        print(f"{i+1:{padding}}) {item}")
    ret = int(input("> Selection: ")) - 1
    if not sys.stdin.isatty():
        print(f"{ret+1}")
    print()
    return ret


def main():
    # TODO: YOUR CODE HERE
    
    # List to store our random 10 games tuples
    pokeGames = []
    # List to store our random 10 games names
    pokeGamesNames = []
    # Variable to store selected game (ID, Game Name)
    selectGame = ()

    # List to store our random 10 Pokemon tuples
    pokemonList = []
    # List to store our random 10 pokemon names
    pokemonListNames = []
    # Variable to store selected pokemon (National ID / Pokemon ID, Regional ID, species, first type, second type, Pokemeon Name)
    selectPokemon = ()

    # List to store our knowable abilities
    abilitiesList = []
    # Variable to store our chosen ability name
    selectAbility = None

    # list to store our move tuples (name, of_type, category, power, accuracy) 
    moveList = []
    # List to store our move names
    moveListName = []
    # List to store our selected moves
    selectMove = []

    # List to store types Tuple form (id,name)
    typeList = []

    # Variables to store the appropriate length for our aligns to give correct output format
    movealign = 0
    typealign = 0
    
    curr = db.cursor()


    #
    # Type
    #

    # Select list of queries and store them in list so can easily convert type id to type name
    typeQry = 'Select * from types order by id;'

    # Execute Query
    curr.execute(typeQry)

    # Fetch results of query and store in out typeList with tuples (id,name)
    for t in curr.fetchall():
        typeList.append(t[1])


    # Query to setseed for psql / select name from games ordered by random()
    seedQry = 'SELECT setseed(%s); SELECT id,name FROM games ORDER BY random() LIMIT 10;'
    curr.execute(seedQry, [str(rng.random())])
    
    #
    # POKEGAME SELECTION
    #
    
    # Loop to append names to our pokegames list
    for t in curr.fetchall():
        pokeGames.append(t)
        pokeGamesNames.append(t[1])
    
    # Passing our pokeGames list to our menu function and storing in result
    result = menu(pokeGamesNames)

    # Storing our selected game in variable
    selectGame = pokeGames[result]

    #
    # POKEMON SELECTION
    #

    # Query to select names from pokemeon ordered randomly
    pokemonQry = '''
                SELECT 
                    national_id, 
                    regional_id, 
                    species, 
                    first_type, 
                    second_type, 
                    name 
                FROM pokemon 
                JOIN pokedex on pokemon.id = pokedex.national_id
                WHERE pokedex.game = %s
                ORDER by random()
                LIMIT 10;
                '''

    # Execute Query
    curr.execute(pokemonQry, [selectGame[0]])

    # Loop to append tuples to our POKEMON list
    for t in curr.fetchall():
        pokemonList.append(t)
        pokemonListNames.append(t[5])

    # Passing our pokemon list to our menu function and storing in result
    result = menu(pokemonListNames)

    # Storing our selected pokemon in variable
    selectPokemon = pokemonList[result]

    #
    # Ability Selection
    #

    # Query to display all abilities known by pokemon
    abilityQry = '''
                Select a.name FROM abilities a
                JOIN knowable_abilities k on a.id = k.knows
                where known_by = %s::pokemon_id 
                ORDER by a.id
                 '''

    # Execute Query
    curr.execute(abilityQry, [selectPokemon[0]])

    # Loop to append abilities to abilities list
    for t in curr.fetchall():
        abilitiesList.append(t[0])

    # Checks if any abilities to select from
    if (abilitiesList):
        # Passing our abilities list to menu and storing in result
        result = menu(abilitiesList)

        # Storing our selected ability in variable
        selectAbility = abilitiesList[result]

    #
    # Move Selection
    # 

    # Move query
    moveQry = '''
            Select 
                distinct m.name, 
                m.of_type, 
                m.category, 
                m.power, 
                m.accuracy,
                m.id
            from moves m
            JOIN learnable_moves l on l.learns = m.id
            JOIN requirements r on r.id = l.learnt_when
            JOIN pokemon p on l.learnt_by = p.id
            WHERE p.id = %s::pokemon_id 
                and r.assertion ~* 'level:'
                and l.learnt_in = %s::integer
            ORDER by m.id;
              '''

    curr.execute(moveQry, [selectPokemon[0], selectGame[0]])

    # Iterate through results of query
    for t in curr.fetchall():
        moveList.append(t)
        moveListName.append(t[0])
    
    # Check if we have >= than 4 moves for them to choose if not limit to length of moves available
    if (len(moveList) >= 4):
        end = 4
    else:
        end = len(moveList)

    # Loop to allow selection of moves
    for i in range(0,end):
        result = menu(moveListName)
        selectMove.append(moveList[result])

        # Condition statement to find longest string of type name to align them accordingly
        if typealign == 0:
            typealign = len(typeList[moveList[result][1]])
        elif typealign < len(typeList[moveList[result][1]]):
            typealign = len(typeList[moveList[result][1]])

        # Condition statement to find longest string of move name to align them accordingly
        if movealign == 0:
            movealign = len(moveListName[result])
        elif movealign < len(moveListName[result]):
            movealign = len(moveListName[result])
            
        # Remove selected move from list
        del moveListName[result]
        del moveList[result]


    # Variable to store selected game (ID, Game Name)
    # Variable to store selected pokemon (National ID / Pokemon ID, Regional ID, species, first type, second type, Pokemeon Name)
    # list to store our move tuples (name, of_type, category, power, accuracy) 

    print(f"Here is your new Pokemon (from Pokemon {selectGame[1]}):\n")
    print(f"Name: {selectPokemon[5]}")
    print(f"Species: {selectPokemon[2]}")
    if (selectPokemon[4] is None):
        print(f"Type: {typeList[selectPokemon[3]]}")
    else:
        print(f"Type: {typeList[selectPokemon[3]]} + {typeList[selectPokemon[4]]}")

    pokedexnum = selectPokemon[0].split(',')
    print(f"Pokedex Number: {selectPokemon[1]} ({pokedexnum[0][1:]})\n")
    print(f"Ability: {selectAbility}")    
    print(f"Moves:")
    for t in selectMove:
        print('        ', end='')
        print(f"{t[0] : <{movealign}} {'['+typeList[t[1]]+']' : <{typealign + 2}} {'(Category: '+t[2]}, Power: {t[3]}, Accuracy: {t[4]})")
    db.close()


if __name__ == '__main__':
    try:
        db = psycopg2.connect(dbname="ass2")
        main()
    except psycopg2.Error as err:
        print("DB error: ", err)
    except Exception as err:
        print("Internal Error: ", err)
        raise err
    finally:
        if db is not None:
            db.close()
    sys.exit(0)
